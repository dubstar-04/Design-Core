import {Point} from './point.js';
import {Entity} from './entity.js';
import {DXFFile} from '../lib/dxf/dxfFile.js';
import {BoundingBox} from '../lib/boundingBox.js';

import {DesignCore} from '../designCore.js';

export class Block extends Entity {
  constructor(data) {
    super(data);
    this.name = '';

    Object.defineProperty(this, 'location', {
      value: new Point(),
      writable: true,
    });

    Object.defineProperty(this, 'flags', {
      value: 1,
      writable: true,
    });

    Object.defineProperty(this, 'items', {
      value: [],
      writable: true,
    });

    if (data) {
      if (data.name || data[2]) {
        // DXF Groupcode 2 - Block Name
        this.name = data.name || data[2];
      }

      if (data.points) {
        this.location = data.points[0];
      }

      if (data.items) {
        this.items = data.items;
      }

      if (data.flags || data[70]) {
        // DXF Groupcode 70 - Block-type flags (bit-coded):
        // 0 = Indicates none of the following flags apply
        // 1 = This is an anonymous block generated by hatching, associative dimensioning, other internal operations, or an application
        // 2 = This block has non-constant attribute definitions (this bit is not set if the block has any attribute definitions that are constant, or has no attribute definitions at all)
        // 4 = This block is an external reference (xref)
        // 8 = This block is an xref overlay
        // 16 = This block is externally dependent
        // 32 = This is a resolved external reference, or dependent of an external reference (ignored on input)
        // 64 = This definition is a referenced external reference (ignored on input)

        this.flags = data.flags || data[70];
      }
    }
  }

  static register() {
    const command = {command: 'Block'};
    return command;
  }

  setStandardFlags() {
    // Set standard flags (bit-coded values)
    this.flags = 1;
  }

  dxf(file) {
    file.writeGroupCode('0', 'BLOCK');
    file.writeGroupCode('5', file.nextHandle(), DXFFile.Version.R2000); // Handle
    file.writeGroupCode('100', 'AcDbEntity', DXFFile.Version.R2000);
    file.writeGroupCode('100', 'AcDbBlockBegin', DXFFile.Version.R2000);
    file.writeGroupCode('8', this.layer);
    file.writeGroupCode('2', this.name);
    file.writeGroupCode('10', this.points[0].x);
    file.writeGroupCode('20', this.points[0].y);
    file.writeGroupCode('30', 0.0);
    file.writeGroupCode('70', this.flags);
    file.writeGroupCode('3', this.name); // Name again
    file.writeGroupCode('1', '');
    file.writeGroupCode('0', 'ENDBLK');
    file.writeGroupCode('5', file.nextHandle(), DXFFile.Version.R2000); // Handle
    file.writeGroupCode('100', 'AcDbEntity', DXFFile.Version.R2000);
    file.writeGroupCode('100', 'AcDbBlockEnd', DXFFile.Version.R2000);
  }

  clearItems() {
    this.items = [];
  }

  addItem(item) {
    this.items.push(item);
  }

  addInsert(data) {
    const point = new Point(data.points[0].x, data.points[0].y);
    this.points[0] = point;
  }

  draw(ctx, scale) {
    if (!this.items.length) {
      // nothing to draw
      return;
    }

    // blocks are associated with an insert point.
    // translate ctx by the insert location
    // this allows the items to be draw without knowing the insert location of the parent block
    ctx.translate(this.points[0].x, this.points[0].y);

    for (let item = 0; item < this.items.length; item++) {
      if (typeof this.items[item].draw == 'function') {
        this.items[item].draw(ctx, scale);
      }
    }

    /*
        //////////////////////////////////////////
        // draw test point for location
        ctx.strokeStyle = colour;
        ctx.lineWidth = 1 / scale;
        ctx.beginPath()
        ctx.moveTo(this.points[0].x, this.points[0].y);
        ctx.arc(this.points[0].x, this.points[0].y, 5 / scale, radians2degrees(0), radians2degrees(360), false);
        ctx.stroke();
        //////////////////////////////////////////
        */
  }

  snaps(mousePoint, delta) {
    let snaps = [];

    if (!this.items.length) {
      // nothing to draw
      return snaps;
    }

    snaps = [this.points[0]];

    for (let item = 0; item < this.items.length; item++) {
      // collect the child item snaps
      const itemSnaps = this.items[item].snaps(mousePoint, delta);

      for (let snap = 0; snap < itemSnaps.length; snap++) {
        // offset the item snap point by the block insert location
        let snapPoint = itemSnaps[snap];
        snapPoint = snapPoint.add(this.points[0]);
        snaps.push(snapPoint);
      }
    }

    return snaps;
  }

  intersectPoints() {
    return {
      start: this.points[0],
      end: this.points[0],
    };
  }

  closestPoint(P) {
    let distance = Infinity;
    let minPnt = P;

    if (!this.items.length) {
      // nothing to draw
      return [minPnt, distance];
    }

    // adjust the selection point to offset by the block insert position
    const adjustedPoint = P.subtract(this.points[0]);

    for (let idx = 0; idx < this.items.length; idx++) {
      const itemClosestPoint = this.items[idx].closestPoint(adjustedPoint);
      const itemPnt = itemClosestPoint[0].add(this.points[0]); // adjust by the block insert position
      const itemDist = itemClosestPoint[1];

      if (itemDist < distance) {
        distance = itemDist;
        minPnt = itemPnt;
      }
    }

    return [minPnt, distance];
  }

  boundingBox() {
    let xmin;
    let xmax;
    let ymin;
    let ymax;

    for (let idx = 0; idx < this.items.length; idx++) {
      const itemBoundingBox = this.items[idx].boundingBox();

      xmin = Math.min(xmin || Infinity, itemBoundingBox.xMin);
      xmax = Math.max(xmax || -Infinity, itemBoundingBox.xMax);
      ymin = Math.min(ymin || Infinity, itemBoundingBox.yMin);
      ymax = Math.max(ymax || -Infinity, itemBoundingBox.yMax);
    }

    const topLeft = new Point(xmin, ymax);
    const bottomRight = new Point(xmax, ymin);

    return new BoundingBox(topLeft, bottomRight);
  }

  touched(selectionExtremes) {
    if (!this.items.length) {
      // nothing to draw
      return false;
    }

    const layer = DesignCore.LayerManager.getStyleByName(this.layer);

    if (!layer.isSelectable) {
      return;
    }

    // Offset selectionExtremes by the block insert position
    const adjustedSelectionExtremes = [
      selectionExtremes[0] - this.points[0].x,
      selectionExtremes[1] - this.points[0].x,
      selectionExtremes[2] - this.points[0].y,
      selectionExtremes[3] - this.points[0].y,
    ];

    for (let idx = 0; idx < this.items.length; idx++) {
      const touched = this.items[idx].touched(adjustedSelectionExtremes);
      if (touched) {
        return true;
      }
    }
  }
}
