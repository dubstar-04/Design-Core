import {Point} from '../entities/point.js';
import {Entity} from '../entities/entity.js';
import {DXFFile} from '../lib/dxf/dxfFile.js';
import {BoundingBox} from '../lib/boundingBox.js';
import {Strings} from '../lib/strings.js';
import {Input, PromptOptions} from '../lib/inputManager.js';

import {DesignCore} from '../designCore.js';

export class Block extends Entity {
  constructor(data) {
    super(data);
    this.name = '';

    Object.defineProperty(this, 'flags', {
      value: 1,
      writable: true,
    });

    Object.defineProperty(this, 'items', {
      value: [],
      writable: true,
    });

    if (data) {
      if (data.hasOwnProperty('name') || data.hasOwnProperty('2')) {
        // DXF Groupcode 2 - Block Name
        this.name = data.name || data[2];
      }

      if (data.hasOwnProperty('items')) {
        this.items = data.items;
      }

      if (data.hasOwnProperty('flags') || data.hasOwnProperty('70')) {
        // DXF Groupcode 70 - Block-type flags (bit-coded):
        // 0 = Indicates none of the following flags apply
        // 1 = This is an anonymous block generated by hatching, associative dimensioning, other internal operations, or an application
        // 2 = This block has non-constant attribute definitions (this bit is not set if the block has any attribute definitions that are constant, or has no attribute definitions at all)
        // 4 = This block is an external reference (xref)
        // 8 = This block is an xref overlay
        // 16 = This block is externally dependent
        // 32 = This is a resolved external reference, or dependent of an external reference (ignored on input)
        // 64 = This definition is a referenced external reference (ignored on input)

        this.flags = data.flags || data[70];
      }
    }
  }

  static register() {
    const command = {command: 'Block', shortcut: 'B'};
    return command;
  }

  async execute() {
    try {
      // set a name
      const name = `Block${DesignCore.Scene.blockManager.blockCount()}`;
      const nameOp = new PromptOptions(`${Strings.Input.NAME} <${name}>`, [
        Input.Type.STRING,
      ]);
      const selectedName =
        await DesignCore.Scene.inputManager.requestInput(nameOp);

      // get the insertion point
      const op2 = new PromptOptions(Strings.Input.BASEPOINT, [
        Input.Type.POINT,
      ]);
      const insertPoint = await DesignCore.Scene.inputManager.requestInput(op2);

      // get the block entities
      const op = new PromptOptions(Strings.Input.SELECTIONSET, [
        Input.Type.SELECTIONSET,
      ]);

      if (!DesignCore.Scene.selectionManager.selectionSet.selectionSet.length) {
        await DesignCore.Scene.inputManager.requestInput(op);
      }

      // create block
      const block = DesignCore.Scene.blockManager.newBlock({
        name: selectedName,
      });

      // get a copy of the selection set
      const selections =
        DesignCore.Scene.selectionManager.selectionSet.selectionSet.slice();
      // sort the selection in descending order
      selections.sort((a, b) => b - a);

      // move selected items from scene to block
      selections.forEach((index) => {
        const item = DesignCore.Scene.items.splice(index, 1)[0];
        // adjust the items points to reflect the insert point
        if (item.hasOwnProperty('points')) {
          item.points.forEach((point) => {
            const np = point.subtract(insertPoint);
            point.x = np.x;
            point.y = np.y;
          });
        }
        block.items.push(item);
      });

      // define insert data
      const insertData = {
        type: 'Insert',
        points: [new Point(insertPoint.x, insertPoint.y)],
        blockName: selectedName,
      };

      // create the insert
      DesignCore.Scene.inputManager.executeCommand(insertData);
    } catch (err) {
      Logging.instance.error(`${this.type} - ${err}`);
    }
  }

  preview() {}

  setStandardFlags() {
    // Set standard flags (bit-coded values)
    this.flags = 1;
  }

  dxf(file) {
    file.writeGroupCode('0', 'BLOCK');
    file.writeGroupCode('5', file.nextHandle(), DXFFile.Version.R2000); // Handle
    file.writeGroupCode('100', 'AcDbEntity', DXFFile.Version.R2000);
    file.writeGroupCode('100', 'AcDbBlockBegin', DXFFile.Version.R2000);
    file.writeGroupCode('8', this.layer);
    file.writeGroupCode('2', this.name);
    file.writeGroupCode('10', this.points[0].x);
    file.writeGroupCode('20', this.points[0].y);
    file.writeGroupCode('30', 0.0);
    file.writeGroupCode('70', this.flags);
    file.writeGroupCode('3', this.name); // Name again
    file.writeGroupCode('1', '');
    file.writeGroupCode('0', 'ENDBLK');
    file.writeGroupCode('5', file.nextHandle(), DXFFile.Version.R2000); // Handle
    file.writeGroupCode('100', 'AcDbEntity', DXFFile.Version.R2000);
    file.writeGroupCode('100', 'AcDbBlockEnd', DXFFile.Version.R2000);
  }

  clearItems() {
    this.items = [];
  }

  addItem(item) {
    this.items.push(item);
  }

  addInsert(data) {
    const point = new Point(data.points[0].x, data.points[0].y);
    this.points[0] = point;
  }

  draw(ctx, scale, insert = undefined) {
    if (!this.items.length) {
      // nothing to draw
      return;
    }

    this.items.forEach((item) => {
      ctx.save();
      // Use the current item and block insert to set the context
      // insert required for colour ByBlock
      DesignCore.Canvas.setContext(item, ctx, insert);

      item.draw(ctx, scale);
      ctx.restore();
    });

    /*
        //////////////////////////////////////////
        // draw test point for location
        ctx.strokeStyle = Colours.rgbToString(colour);
        ctx.lineWidth = 1 / scale;
        ctx.beginPath()
        ctx.moveTo(this.points[0].x, this.points[0].y);
        ctx.arc(this.points[0].x, this.points[0].y, 5 / scale, radians2degrees(0), radians2degrees(360), false);
        ctx.stroke();
        //////////////////////////////////////////
        */
  }

  snaps(mousePoint, delta) {
    let snaps = [];

    if (!this.items.length) {
      // nothing to draw
      return snaps;
    }

    snaps = [this.points[0]];

    for (let item = 0; item < this.items.length; item++) {
      // collect the child item snaps
      const itemSnaps = this.items[item].snaps(mousePoint, delta);

      for (let snap = 0; snap < itemSnaps.length; snap++) {
        // offset the item snap point by the block insert location
        let snapPoint = itemSnaps[snap];
        snapPoint = snapPoint.add(this.points[0]);
        snaps.push(snapPoint);
      }
    }

    return snaps;
  }

  intersectPoints() {
    return {
      start: this.points[0],
      end: this.points[0],
    };
  }

  closestPoint(P) {
    let distance = Infinity;
    let minPnt = P;

    if (!this.items.length) {
      // nothing to draw
      return [minPnt, distance];
    }

    // adjust the selection point to offset by the block insert position
    // const adjustedPoint = P.subtract(this.points[0]);

    for (let idx = 0; idx < this.items.length; idx++) {
      const itemClosestPoint = this.items[idx].closestPoint(P);
      const itemPnt = itemClosestPoint[0]; // .add(this.points[0]); // adjust by the block insert position
      const itemDist = itemClosestPoint[1];

      if (itemDist < distance) {
        distance = itemDist;
        minPnt = itemPnt;
      }
    }

    return [minPnt, distance];
  }

  boundingBox() {
    let xmin;
    let xmax;
    let ymin;
    let ymax;

    for (let idx = 0; idx < this.items.length; idx++) {
      const itemBoundingBox = this.items[idx].boundingBox();

      xmin = Math.min(xmin || Infinity, itemBoundingBox.xMin);
      xmax = Math.max(xmax || -Infinity, itemBoundingBox.xMax);
      ymin = Math.min(ymin || Infinity, itemBoundingBox.yMin);
      ymax = Math.max(ymax || -Infinity, itemBoundingBox.yMax);
    }

    const topLeft = new Point(xmin, ymax);
    const bottomRight = new Point(xmax, ymin);

    return new BoundingBox(topLeft, bottomRight);
  }

  touched(selectionExtremes) {
    if (!this.items.length) {
      // nothing to draw
      return false;
    }

    const layer = DesignCore.LayerManager.getStyleByName(this.layer);

    if (!layer.isSelectable) {
      return;
    }

    // Offset selectionExtremes by the block insert position
    const adjustedSelectionExtremes = [
      selectionExtremes[0] - this.points[0].x,
      selectionExtremes[1] - this.points[0].x,
      selectionExtremes[2] - this.points[0].y,
      selectionExtremes[3] - this.points[0].y,
    ];

    for (let idx = 0; idx < this.items.length; idx++) {
      const touched = this.items[idx].touched(adjustedSelectionExtremes);
      if (touched) {
        return true;
      }
    }
  }
}
